(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{404:function(v,_,l){"use strict";l.r(_);var i=l(43),t=Object(i.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h2",{attrs:{id:"数据结构和算法"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#数据结构和算法"}},[v._v("#")]),v._v(" 数据结构和算法")]),v._v(" "),l("h3",{attrs:{id:"链表"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[v._v("#")]),v._v(" 链表")]),v._v(" "),l("ul",[l("li",[v._v("双向链表，循环链表")])]),v._v(" "),l("h3",{attrs:{id:"栈"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[v._v("#")]),v._v(" 栈")]),v._v(" "),l("ul",[l("li",[v._v("逆波兰表达式（中缀表达式）")])]),v._v(" "),l("h3",{attrs:{id:"队列"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#队列"}},[v._v("#")]),v._v(" 队列")]),v._v(" "),l("ul",[l("li",[v._v("循环队列")])]),v._v(" "),l("h3",{attrs:{id:"树"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#树"}},[v._v("#")]),v._v(" 树")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("树的基本概念")]),v._v(" "),l("ul",[l("li",[v._v("结点")]),v._v(" "),l("li",[v._v("层次")]),v._v(" "),l("li",[v._v("深度（高）")]),v._v(" "),l("li",[v._v("有序树和无序树")]),v._v(" "),l("li",[v._v("森林")])])]),v._v(" "),l("li",[l("p",[v._v("树的存储结构")]),v._v(" "),l("ul",[l("li",[v._v("双亲表示法")]),v._v(" "),l("li",[v._v("孩子表示法")]),v._v(" "),l("li",[v._v("孩子兄弟表示法")])])]),v._v(" "),l("li",[l("p",[v._v("树的遍历的几种方式")]),v._v(" "),l("ul",[l("li",[v._v("深度优先遍历：中序遍历、前序遍历和后序遍历")]),v._v(" "),l("li",[v._v("广度优先遍历：层次遍历")])])]),v._v(" "),l("li",[l("p",[v._v("二叉搜索树的实现")])]),v._v(" "),l("li",[l("p",[v._v("二叉树的类型")]),v._v(" "),l("ul",[l("li",[v._v("特殊二叉树")]),v._v(" "),l("li",[v._v("满二叉树")]),v._v(" "),l("li",[v._v("完全二叉树")])])]),v._v(" "),l("li",[l("p",[v._v("二叉树的存储结构")])]),v._v(" "),l("li",[l("p",[v._v("二叉树的遍历")])]),v._v(" "),l("li",[l("p",[v._v("二叉树的建立")]),v._v(" "),l("ul",[l("li",[v._v("树、森林、二叉树的转换")]),v._v(" "),l("li",[v._v("贺夫曼树、赫夫曼编码（压缩算法）")])])]),v._v(" "),l("li",[l("p",[v._v("平衡二叉树，平衡二叉查找树，红黑树")])]),v._v(" "),l("li",[l("p",[v._v("B树、B+树")])])]),v._v(" "),l("h3",{attrs:{id:"图"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#图"}},[v._v("#")]),v._v(" 图")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("图的特性与基本概念")]),v._v(" "),l("ul",[l("li",[v._v("有向图")]),v._v(" "),l("li",[v._v("无向图")]),v._v(" "),l("li",[v._v("图的权值")]),v._v(" "),l("li",[v._v("连通图")]),v._v(" "),l("li",[v._v("图的度")])])]),v._v(" "),l("li",[l("p",[v._v("图的存储结构")]),v._v(" "),l("ul",[l("li",[v._v("邻接矩阵")]),v._v(" "),l("li",[v._v("带权邻接矩阵")]),v._v(" "),l("li",[v._v("邻接表")]),v._v(" "),l("li",[v._v("带权值邻接表")]),v._v(" "),l("li",[v._v("十字链表")])])]),v._v(" "),l("li",[l("p",[v._v("图的遍历")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("深度优先遍历")])]),v._v(" "),l("li",[l("p",[v._v("广度优先遍历")])]),v._v(" "),l("li",[l("p",[v._v("最小生成树")]),v._v(" "),l("ul",[l("li",[v._v("普里姆算法")]),v._v(" "),l("li",[v._v("克鲁斯卡尔算法")])])]),v._v(" "),l("li",[l("p",[v._v("最短路径")]),v._v(" "),l("ul",[l("li",[v._v("迪克斯特拉算法")])])])])])]),v._v(" "),l("h3",{attrs:{id:"其他"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#其他"}},[v._v("#")]),v._v(" 其他")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("散列表")])]),v._v(" "),l("li",[l("p",[v._v("哈希算法")])])])])}),[],!1,null,null,null);_.default=t.exports}}]);