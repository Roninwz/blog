(window.webpackJsonp=window.webpackJsonp||[]).push([[268],{627:function(t,e,o){"use strict";o.r(e);var s=o(43),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,o=t._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("h2",{attrs:{id:"es6面试题"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#es6面试题"}},[t._v("#")]),t._v(" es6面试题")]),t._v(" "),o("h3",{attrs:{id:"_1-es6新特性"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-es6新特性"}},[t._v("#")]),t._v(" 1.ES6新特性")]),t._v(" "),o("h3",{attrs:{id:"_2-symbol及使用"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-symbol及使用"}},[t._v("#")]),t._v(" 2.Symbol及使用")]),t._v(" "),o("blockquote",[o("p",[t._v("ES6 引入了一种新的原始数据类型 Symbol ，表示独一无二的值，最大的用法是用来定义对象的唯一属性名。")])]),t._v(" "),o("ul",[o("li",[t._v("声明，使用Symbol函数 "),o("code",[t._v("let s1 = Symbol('foo');")])])]),t._v(" "),o("blockquote",[o("p",[t._v("Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。"),o("br"),t._v("\nSymbol 值作为对象属性名时，不能用点运算符,要使用[]"),o("br"),t._v("\nSymbol 值作为属性名时，该属性是公有属性不是私有属性，可以在类的外部访问。但是不会出现在 for...in 、 for...of 的循环中，也不会被 Object.keys() 、 Object.getOwnPropertyNames() 返回。如果要读取到一个对象的 Symbol 属性，可以通过 Object.getOwnPropertySymbols() 和 Reflect.ownKeys() 取到。")])])])}),[],!1,null,null,null);e.default=r.exports}}]);