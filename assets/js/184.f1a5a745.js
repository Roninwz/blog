(window.webpackJsonp=window.webpackJsonp||[]).push([[184],{539:function(e,a,l){"use strict";l.r(a);var _=l(43),r=Object(_.a)({},(function(){var e=this,a=e.$createElement,l=e._self._c||a;return l("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[l("h1",{attrs:{id:"webpack"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#webpack"}},[e._v("#")]),e._v(" webpack")]),e._v(" "),l("h3",{attrs:{id:"_1-webpack-如何实现动态加载"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_1-webpack-如何实现动态加载"}},[e._v("#")]),e._v(" "),l("strong",[e._v("1.webpack 如何实现动态加载")])]),e._v(" "),l("ul",[l("li",[l("strong",[e._v("import() 语法 来实现动态导入。")])]),e._v(" "),l("li",[l("strong",[e._v("使用 webpack 特定的 require.ensure")])])]),e._v(" "),l("h3",{attrs:{id:"_2-loader-和-plugin-的作用是什么，loader-和-plugin-的区别"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_2-loader-和-plugin-的作用是什么，loader-和-plugin-的区别"}},[e._v("#")]),e._v(" 2.loader 和 plugin 的作用是什么，loader 和 plugin 的区别")]),e._v(" "),l("blockquote",[l("p",[e._v("对于 loader，它就是一个转换器，将 A 文件进行编译形成 B 文件，这里操作的是文件，比如将 A.scss 或 A.less 转变为 B.css，单纯的文件转换过程；\n对于 plugin，它就是一个扩展器，它丰富了 wepack 本身，针对是 loader 结束后，webpack 打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些节点")])]),e._v(" "),l("ul",[l("li",[e._v("loader，它是一个转换器，用于对模块源码的转换，")]),e._v(" "),l("li",[e._v("plugin 是一个扩展器，为了扩展 webpack 的功能，目的在于解决 loader 无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务")])]),e._v(" "),l("h3",{attrs:{id:"_3-webpack-用过哪些-loader-和-plugin"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_3-webpack-用过哪些-loader-和-plugin"}},[e._v("#")]),e._v(" "),l("strong",[e._v("3.Webpack 用过哪些 loader 和 plugin?")])]),e._v(" "),l("p",[e._v("loader:")]),e._v(" "),l("ul",[l("li",[e._v("css-loader：处理 css 文件路径")]),e._v(" "),l("li",[e._v("style-loader：通过 "),l("code",[e._v("<style>")]),e._v(" 标签将 css 插入到 DOM 中")]),e._v(" "),l("li",[e._v("script-loader、")]),e._v(" "),l("li",[e._v("postcss-loader：兼容，自动加上浏览器兼容性前缀")]),e._v(" "),l("li",[e._v("sass-loader：加载 sass/scss 文件并且变异成 css")]),e._v(" "),l("li",[e._v("vue-loader：允许你以一种名为"),l("a",{attrs:{href:"https://vue-loader.vuejs.org/zh/spec.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("单文件组件 (SFCs)"),l("OutboundLink")],1),e._v("的格式撰写 Vue 组件。")]),e._v(" "),l("li",[e._v("eslint-loader：让 webpack 支持 eslint")]),e._v(" "),l("li",[e._v("url-loader：")]),e._v(" "),l("li",[l("strong",[e._v("file-loader")]),e._v("：处理图片路径问题")]),e._v(" "),l("li",[e._v("svg-sprite-loader：创建 SVG 雪碧图")])]),e._v(" "),l("p",[e._v("plugin:")]),e._v(" "),l("ul",[l("li",[e._v("html-webpack-plugin: webpack 打包后自动生成 html")]),e._v(" "),l("li",[e._v("uglifyjs-webpack-plugin：js 代码压缩")]),e._v(" "),l("li",[e._v("clean-webpack-plugin：编译输出文件前，删除旧文件，当利用文件 hash 值输出时，可以利用改插件删除原有文件（即每次打包时清空指定文件夹）")]),e._v(" "),l("li",[e._v("copy-webpack-plugin：拷贝单个文件或多个文件或整个目录,比如 static 文件夹拷贝")])]),e._v(" "),l("h3",{attrs:{id:"_4-webpack-打包的具体原理"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_4-webpack-打包的具体原理"}},[e._v("#")]),e._v(" "),l("strong",[e._v("4.Webpack 打包的具体原理")])]),e._v(" "),l("ul",[l("li",[e._v("利用 babel 完成代码转换,并生成单个文件的依赖")]),e._v(" "),l("li",[e._v("从入口开始递归分析，并生成依赖图谱")]),e._v(" "),l("li",[e._v("将各个引用模块打包为一个立即执行函数")]),e._v(" "),l("li",[e._v("将最终的 bundle 文件写入 bundle.js 中")])]),e._v(" "),l("h3",{attrs:{id:"_5-webpack-的打包过程"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_5-webpack-的打包过程"}},[e._v("#")]),e._v(" "),l("strong",[e._v("5.webpack 的打包过程")])]),e._v(" "),l("ul",[l("li",[e._v("初始化参数 从配置文件和 Shell 语句中读取与合并参数，得出最终的参数")]),e._v(" "),l("li",[e._v("开始编译 用上一步得到的参数初始 Compiler 对象，加载所有配置的插件，通 过执行对象的 run 方法开始执行编译")]),e._v(" "),l("li",[e._v("确定入口 根据配置中的 Entry 找出所有入口文件")]),e._v(" "),l("li",[e._v("编译模块 从入口文件出发，调用所有配置的 Loader 对模块进行编译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理")]),e._v(" "),l("li",[e._v("完成模块编译 在经过第 4 步使用 Loader 翻译完所有模块后， 得到了每个模块被编译后的最终内容及它们之间的依赖关系")]),e._v(" "),l("li",[e._v("输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk,再将每个 Chunk 转换成一个单独的文件加入输出列表中，这是可以修改输出内容的最后机会")]),e._v(" "),l("li",[e._v("输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，将文件的内容写入文件系统中。")])]),e._v(" "),l("h3",{attrs:{id:"_6-webpack-拆包-代码分离"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_6-webpack-拆包-代码分离"}},[e._v("#")]),e._v(" "),l("strong",[e._v("6.webpack 拆包(代码分离)")])]),e._v(" "),l("ul",[l("li",[l("p",[e._v("入口起点：使用 "),l("a",{attrs:{href:"https://webpack.docschina.org/configuration/entry-context",target:"_blank",rel:"noopener noreferrer"}},[l("code",[e._v("entry")]),l("OutboundLink")],1),e._v(" 配置手动地分离代码。")])]),e._v(" "),l("li",[l("p",[e._v("防止重复：使用 "),l("a",{attrs:{href:"https://webpack.docschina.org/plugins/split-chunks-plugin/",target:"_blank",rel:"noopener noreferrer"}},[l("code",[e._v("SplitChunksPlugin")]),l("OutboundLink")],1),e._v(" 去重和分离 chunk。")])]),e._v(" "),l("li",[l("p",[e._v("动态导入：通过模块中的内联函数调用来分离代码。")])])]),e._v(" "),l("p",[e._v("使用 webpack 拆包功能，从 bundle.js 中拆分出多个 chunk.js，实现 js 的按需加载，可以提高首屏加载速度")]),e._v(" "),l("p",[e._v("webpack4 取消了 CommonsChunkPlugin，使用 splitChunks 进行拆包")]),e._v(" "),l("h3",{attrs:{id:"_7-自己编写-webpack-插件"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_7-自己编写-webpack-插件"}},[e._v("#")]),e._v(" 7. 自己编写 webpack 插件")]),e._v(" "),l("ul",[l("li",[e._v("一个 JavaScript 命名函数。")]),e._v(" "),l("li",[e._v("在插件函数的 prototype 上定义一个 apply 方法。，方法传入 compiler 参数(compiler 对象代表了完整的 webpack 环境配置) 。")]),e._v(" "),l("li",[e._v("指定一个绑定到 webpack 自身的事件钩子。")]),e._v(" "),l("li",[e._v("处理 webpack 内部实例的特定数据。")]),e._v(" "),l("li",[e._v("功能完成后调用 webpack 提供的回调。")])]),e._v(" "),l("h3",{attrs:{id:"_100-webpack4-区别"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_100-webpack4-区别"}},[e._v("#")]),e._v(" "),l("strong",[e._v("100.webpack4 区别")])]),e._v(" "),l("ul",[l("li",[e._v("1、取消了 UglifyjsWebpackPlugin，使用 minimize 进行压缩，")]),e._v(" "),l("li",[e._v("2、取消了 CommonsChunkPlugin，使用 splitChunks 进行分包。")])])])}),[],!1,null,null,null);a.default=r.exports}}]);