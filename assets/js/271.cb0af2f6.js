(window.webpackJsonp=window.webpackJsonp||[]).push([[271],{631:function(e,t,r){"use strict";r.r(t);var a=r(43),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"node"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#node"}},[e._v("#")]),e._v(" node")]),e._v(" "),r("ul",[r("li",[e._v("node 主要用来解决什么问题？")])]),e._v(" "),r("h3",{attrs:{id:"node-做-bff-的优点是什么？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#node-做-bff-的优点是什么？"}},[e._v("#")]),e._v(" node 做 BFF 的优点是什么？")]),e._v(" "),r("p",[e._v("中间层概念，就是加一层 nodejs，能做请求转发和数据转化即可。Nodejs 既配合了前端技术栈，也更适应向微服务的并发请求。")]),e._v(" "),r("h3",{attrs:{id:"如何解决异步回调地狱"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何解决异步回调地狱"}},[e._v("#")]),e._v(" 如何解决异步回调地狱")]),e._v(" "),r("p",[e._v("（1）拆解 function\n（2）事件发布/监听模式\n（3）promise\n（4）generator\n（5）async/await")]),e._v(" "),r("ul",[r("li",[e._v("Nodejs 的线程管理")])]),e._v(" "),r("h3",{attrs:{id:"nodejs-如何-require-一个包"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#nodejs-如何-require-一个包"}},[e._v("#")]),e._v(" nodejs 如何 require 一个包")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("原生模块")]),e._v(" "),r("blockquote",[r("p",[e._v("require('包名')")])])]),e._v(" "),r("li",[r("p",[e._v("自定义模块")]),e._v(" "),r("blockquote",[r("p",[e._v("相对路径 require('./包名')\n绝对路径 require('/包名')")])])])]),e._v(" "),r("ul",[r("li",[e._v("第三方模块\n"),r("blockquote",[r("p",[e._v("require('包名')")])])])]),e._v(" "),r("blockquote",[r("p",[e._v("采用的是 CommonJS 规范")])]),e._v(" "),r("ul",[r("li",[e._v("node 中 cluster 是怎样开启多进程的，并且一个端口可以被多个进程监听吗")]),e._v(" "),r("li",[e._v("node 进程中怎么通信")])]),e._v(" "),r("h3",{attrs:{id:"node-创建进程的四种方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#node-创建进程的四种方式"}},[e._v("#")]),e._v(" node 创建进程的四种方式")]),e._v(" "),r("p",[e._v("Node 有 4 种创建进程的方式： spawn() ， exec() ， execFile() 和 fork()")]),e._v(" "),r("h3",{attrs:{id:"node-可以开启多线程吗"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#node-可以开启多线程吗"}},[e._v("#")]),e._v(" node 可以开启多线程吗")]),e._v(" "),r("h3",{attrs:{id:"buffer-模块是干什么的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#buffer-模块是干什么的"}},[e._v("#")]),e._v(" Buffer 模块是干什么的")]),e._v(" "),r("blockquote",[r("p",[e._v("Buffer 类:Buffer 是用与读取或操作二进制数据流的全局变量.")])]),e._v(" "),r("blockquote",[r("p",[e._v("Buffer 大小固定,在被创建的时候确定,无法调整.")])]),e._v(" "),r("blockquote",[r("p",[e._v("Buffer 的使用场景, 非 utf8 字符存储 post 数据 concat.")])]),e._v(" "),r("h3",{attrs:{id:"buffer-和字符串区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#buffer-和字符串区别"}},[e._v("#")]),e._v(" Buffer 和字符串区别")]),e._v(" "),r("ul",[r("li",[e._v("Buffer 与字符串有一个重要区别。字符串是只读的，并且对字符串的任何修改得到的都是一个新字符串，原字符串保持不变。")])]),e._v(" "),r("p",[e._v("至于 Buffer，更像是可以做指针操作的 C 语言数组。例如，可以用[index]方式直接修改某个位置的字节。")]),e._v(" "),r("ul",[r("li",[e._v("字符串转 Buffer")])]),e._v(" "),r("p",[e._v("new Buffer(str, [encoding])，默认 UTF-8\nbuf.write(string, [offset], [length], [encoding])")]),e._v(" "),r("ul",[r("li",[e._v("Buffer 转字符串")])]),e._v(" "),r("p",[e._v("buf.toString([encoding], [start], [end])")]),e._v(" "),r("h3",{attrs:{id:"stream-是什么，使用的两种模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#stream-是什么，使用的两种模式"}},[e._v("#")]),e._v(" Stream 是什么，使用的两种模式")]),e._v(" "),r("blockquote",[r("p",[e._v("流中的数据有两种模式,二进制模式和对象模式.\n二进制模式, 每个分块都是 buffer 或者 string 对象.\n对象模式, 流内部处理的是一系列普通对象.")])]),e._v(" "),r("h3",{attrs:{id:"stream-的几种类型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#stream-的几种类型"}},[e._v("#")]),e._v(" Stream 的几种类型")]),e._v(" "),r("ul",[r("li",[e._v("Readable (可读流)")]),e._v(" "),r("li",[e._v("Writable (可写流)")]),e._v(" "),r("li",[e._v("Duplex (读写流)")]),e._v(" "),r("li",[e._v("Transform (转换流)")])]),e._v(" "),r("h3",{attrs:{id:"http-模块如何将异步处理方式实现成同步处理方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#http-模块如何将异步处理方式实现成同步处理方式"}},[e._v("#")]),e._v(" http 模块如何将异步处理方式实现成同步处理方式")])])}),[],!1,null,null,null);t.default=s.exports}}]);