(window.webpackJsonp=window.webpackJsonp||[]).push([[120],{468:function(e,t,v){"use strict";v.r(t);var r=v(43),_=Object(r.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h3",{attrs:{id:"创建对象三种方式的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#创建对象三种方式的区别"}},[e._v("#")]),e._v(" 创建对象三种方式的区别")]),e._v(" "),v("blockquote",[v("p",[e._v("创建对象使用{}、new object()、object.create()的区别"),v("br"),e._v("\n前言"),v("br"),e._v("\n在 js 中，创建对象有三种方式"),v("br"),e._v("\n{} // 对象字面量"),v("br"),e._v("\nnew Object()"),v("br"),e._v("\nObject.create()"),v("br"),e._v("\n1 和 2 的区别很小，1 不能传参，2 可以传参。"),v("br"),e._v("\nnew Object() 和 Object.create() 区别就比较大了")])]),e._v(" "),v("ul",[v("li",[v("ol",[v("li",[e._v("new 关键字")])])])]),e._v(" "),v("p",[e._v("new 关键字做了几件事")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",[v("code",[e._v("创建一个新对象\n将新对象的原型指向构造函数的原型\n执行构造函数，绑定this\n返回这个对象\n")])])]),v("p",[e._v("比如创建一个 Car 对象，伪代码")]),e._v(" "),v("p",[e._v("// new Car()\nvar obj = new Object()\nobj."),v("em",[e._v("proto")]),e._v(" = Car.prototype\n// 执行构造函数, 绑定 this\nCar.call(obj)")]),e._v(" "),v("p",[e._v("我们注意到比较关键的地方是，它调用了 Car 对象的构造函数，并通过 call 将 obj 的 this 绑定到了 Car 对象上")]),e._v(" "),v("p",[e._v("这一步操作将 Car 对象上的属性，继承到了 obj 上")]),e._v(" "),v("ul",[v("li",[v("ol",{attrs:{start:"2"}},[v("li",[e._v("Object.create()")])])])]),e._v(" "),v("p",[e._v("Object.create 做了什么事情呢？")]),e._v(" "),v("p",[e._v("它同样是创建一个新对象，将新对象的原型关联到构造函数上")]),e._v(" "),v("p",[e._v("var f = function() { }\nf.prototype = Car\nreturn new f()")]),e._v(" "),v("p",[e._v("可以看出，在 Object.create 的内部，并没有去调用 Car 构造函数，而是调用了创建新对象的构造函数，因此 Car 上的属性不会继承到 Object.create 创建的实例中")]),e._v(" "),v("ul",[v("li",[v("ol",{attrs:{start:"3"}},[v("li",[e._v("例子")])])])]),e._v(" "),v("p",[e._v("比较鲜明的地方是在继承的时候")]),e._v(" "),v("p",[e._v("子类去继承父类的原型方法的时候，很多人会这样写")]),e._v(" "),v("p",[e._v("// 父类是 People，子类是 Male\nMale.prototype = new People()")]),e._v(" "),v("p",[e._v("new 确实能够继承，但是调用了父类的构造函数，把父类的属性也给继承到了原型上，但是我们仅仅只是想要父类的原型方法，所以这样写是存在副作用的")]),e._v(" "),v("p",[e._v("正确的写法应该是")]),e._v(" "),v("p",[e._v("Male.prototype = Object.create(People.prototype)")]),e._v(" "),v("p",[e._v("这种方式，不会调用父类的构造函数，而是生成新对象，将新对象与父类原型关联，然后 new 这个新对象返回")]),e._v(" "),v("p",[e._v("将 new 构造函数的方式转变了成 new 新对象的方式，这样就更加纯净，干脆")])])}),[],!1,null,null,null);t.default=_.exports}}]);