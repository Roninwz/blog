(window.webpackJsonp=window.webpackJsonp||[]).push([[267],{626:function(t,a,s){"use strict";s.r(a);var n=s(43),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"js-面试题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js-面试题"}},[t._v("#")]),t._v(" JS 面试题")]),t._v(" "),s("h3",{attrs:{id:"_1-js-继承的几种方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-js-继承的几种方式"}},[t._v("#")]),t._v(" 1.JS 继承的几种方式")]),t._v(" "),s("ul",[s("li",[t._v("(1) 原型链继承：将父类的实例作为子类的原型"),s("code",[t._v("Cat.prototype = new Animal();")])]),t._v(" "),s("li",[t._v("(2)构造继承：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型，用 call）")])]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Cat")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Animal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("ul",[s("li",[t._v("(3) 实例继承：为父类实例添加新特性，作为子类实例返回")])]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Cat")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" instance "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Animal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" instance\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("ul",[s("li",[t._v("(4) 拷贝继承：拷贝父类的属性")])]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Cat")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" animal "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Animal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" p "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" animal"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Cat")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("p"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" animal"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("p"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br")])]),s("ul",[s("li",[t._v("(5) 组合继承：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用")])]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Cat")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Animal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Cat")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Animal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 组合继承也是需要修复构造函数指向的。")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Cat")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("constructor "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Cat\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br")])]),s("ul",[s("li",[t._v("(6) 寄生组合继承")]),t._v(" "),s("li",[t._v("详解 "),s("a",{attrs:{href:"https://www.cnblogs.com/humin/p/4556820.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.cnblogs.com/humin/p/4556820.html"),s("OutboundLink")],1)])]),t._v(" "),s("h3",{attrs:{id:"_2-instanceof-实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-instanceof-实现原理"}},[t._v("#")]),t._v(" 2.instanceof 实现原理")]),t._v(" "),s("p",[t._v("instanceof 其实是通过原型链来实现继承关系的判断，实现 instanceof 时，实际调用的是 HasInstance 这个内置方法")]),t._v(" "),s("h3",{attrs:{id:"_3-async-await-和-promise-区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-async-await-和-promise-区别"}},[t._v("#")]),t._v(" 3.async await 和 promise 区别")]),t._v(" "),s("ul",[s("li",[t._v("简洁，可以让异步代码看起来就像同步代码那样，提高可读性")]),t._v(" "),s("li",[t._v("Async/Await 让 try/catch 可以同时处理同步和异步错误，Promise 中。我们需要使用.catch")]),t._v(" "),s("li",[t._v("错误栈，async/await 中的错误栈会指向错误所在的函数，Promise 链中返回的错误栈没有给出错误发生位置的线索")]),t._v(" "),s("li",[t._v("调试简单，如果你在.then 代码块中设置断点，使用 Step Over 快捷键，调试器不会跳到下一个.then，因为它只会跳过异步代码。")])]),t._v(" "),s("h3",{attrs:{id:"_4-箭头函数跟普通函数的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-箭头函数跟普通函数的区别"}},[t._v("#")]),t._v(" 4.箭头函数跟普通函数的区别")]),t._v(" "),s("ul",[s("li",[t._v("箭头函数是匿名函数，不能作为构造函数，不能使用 new")]),t._v(" "),s("li",[t._v("箭头函数不绑定 this，会捕获其所在的上下文的 this 值，作为自己的 this 值")]),t._v(" "),s("li",[t._v("箭头函数没有原型属性")]),t._v(" "),s("li",[t._v("箭头函数不绑定 arguments，取而代之用 rest 参数...解决")])]),t._v(" "),s("h3",{attrs:{id:"_5-prototype-和proto的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-prototype-和proto的区别"}},[t._v("#")]),t._v(" 5.prototype 和"),s("strong",[t._v("proto")]),t._v("的区别")]),t._v(" "),s("ul",[s("li",[t._v("prototype 是构造函数的属性。 "),s("strong",[t._v("proto")]),t._v(" 是每个实例都有的属性")]),t._v(" "),s("li",[t._v("1.对象有属性"),s("strong",[t._v("proto")]),t._v(",指向该对象的构造函数的原型对象。")]),t._v(" "),s("li",[t._v("2.函数除了有属性"),s("strong",[t._v("proto")]),t._v(",还有属性 prototype，prototype 指向该函数的原型对象。")])]),t._v(" "),s("h3",{attrs:{id:"_6-js-的-new-操作符做了哪些事情"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-js-的-new-操作符做了哪些事情"}},[t._v("#")]),t._v(" 6.js 的 new 操作符做了哪些事情")]),t._v(" "),s("ul",[s("li",[t._v("创建一个空的对象")]),t._v(" "),s("li",[t._v("链接到原型")]),t._v(" "),s("li",[t._v("绑定 this 指向，执行构造函数")]),t._v(" "),s("li",[t._v("返回对象")])]),t._v(" "),s("h3",{attrs:{id:"_7-mouseenter、mouseleave、mouseover-和-mouseout-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-mouseenter、mouseleave、mouseover-和-mouseout-的区别"}},[t._v("#")]),t._v(" 7.mouseenter、mouseleave、mouseover 和 mouseout 的区别")]),t._v(" "),s("ul",[s("li",[t._v("mouseover 和 mouseout 会冒泡，在父元素和其子元素都可以触发，当鼠标穿过一个元素时，触发次数得依子元素数量而言。")]),t._v(" "),s("li",[t._v("mouseenter 和 mouseleave 只在父元素触发，当鼠标穿过一个元素时，只会触发一次。")]),t._v(" "),s("li",[t._v("mouseover 和 mouseout 比 mouseenter 和 mouseleave 先触发")])]),t._v(" "),s("h3",{attrs:{id:"_8-script-标签中-async-跟-defer-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-script-标签中-async-跟-defer-的区别"}},[t._v("#")]),t._v(" 8.script 标签中 async 跟 defer 的区别")]),t._v(" "),s("ul",[s("li",[t._v("没有 defer 或 async 属性，浏览器会立即加载并执行相应的脚本。同步，不等待，此举会阻塞后续文档的加载；")]),t._v(" "),s("li",[t._v("async: 表示后续文档的加载和渲染与 js 脚本的加载和执行是异步执行的，但是标记为 async 的脚本并不保证按照指定它们的先后顺序执行，也就是说后面的 js 脚本可能先于之前的 Js 脚本执行；")]),t._v(" "),s("li",[t._v("defer: 加载后续文档的过程和 js 脚本的加载(此时仅加载不执行)是异步进行的，js 脚本的执行需要等到文档所有元素解析完成之后，DOMContentLoaded 事件触发执行之前。")]),t._v(" "),s("li",[t._v("当 script 同时有 async 和 defer 属性时，执行效果和 async 一致。")])]),t._v(" "),s("h3",{attrs:{id:"_9-var、let、const-区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-var、let、const-区别"}},[t._v("#")]),t._v(" 9.var、let、const 区别")]),t._v(" "),s("ul",[s("li",[t._v("const 声明的变量必须经过初始化。不能重新赋值，")]),t._v(" "),s("li",[t._v("var 是允许在相同作用域内重复声明同一个变量的，而 let 与 const 不允许这一现象")]),t._v(" "),s("li",[t._v("var 可以先使用，后声明；let 必须先声明后使用。")]),t._v(" "),s("li",[t._v("暂时性死区：只要块级作用域内存在 let 命令，它所声明的变量就“绑定”（binding）这个区域， 不再受外部的影响。")])]),t._v(" "),s("h3",{attrs:{id:"_10-js-垃圾回收机制的理解及算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-js-垃圾回收机制的理解及算法"}},[t._v("#")]),t._v(" 10.JS 垃圾回收机制的理解及算法")]),t._v(" "),s("p",[t._v("js 的垃圾回收机制就是为了防止内存泄漏的，Javascript 具有自动垃圾回收机制，")]),t._v(" "),s("p",[t._v("垃圾回收算法：1、标记清除 2、引用计数")]),t._v(" "),s("p",[t._v("标记清除算法工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。")]),t._v(" "),s("p",[t._v("引用计数：如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。")]),t._v(" "),s("p",[t._v("详解："),s("a",{attrs:{href:"https://www.cnblogs.com/mayun0504/p/10646620.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.cnblogs.com/mayun0504/p/10646620.html"),s("OutboundLink")],1)]),t._v(" "),s("h3",{attrs:{id:"_11-内存泄漏和内存溢出"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_11-内存泄漏和内存溢出"}},[t._v("#")]),t._v(" 11.内存泄漏和内存溢出")]),t._v(" "),s("p",[t._v("内存泄漏可以定义为程序不再使用或不需要的一块内存，但是由于某种原因没有被释放仍然被不必要的占有。")]),t._v(" "),s("p",[t._v("内存泄漏：")]),t._v(" "),s("p",[t._v("1、全局变量")]),t._v(" "),s("p",[t._v("2、被遗漏的定时器或者回调函数，解决方法： 在定时器完成工作的时候，手动清除定时器")]),t._v(" "),s("p",[t._v("3、保留了 DOM 节点的引用,导致 GC 没有回收")]),t._v(" "),s("p",[t._v("4、错误使用闭包")]),t._v(" "),s("p",[t._v("详解："),s("a",{attrs:{href:"https://segmentfault.com/a/1190000020114344",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://segmentfault.com/a/1190000020114344"),s("OutboundLink")],1)]),t._v(" "),s("h4",{attrs:{id:""}},[s("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])]),t._v(" "),s("p",[t._v("内存溢出是一种程序运行出现的错误； 当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误")]),t._v(" "),s("p",[t._v("内存溢出一般是内存泄漏造成的，占用的内存不需要用到了但是没有及时释放，内存泄漏积累的多了轻的话影响系统性能，严重直接引起内存溢出系统崩溃。")]),t._v(" "),s("h3",{attrs:{id:"_12-闭包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_12-闭包"}},[t._v("#")]),t._v(" 12.闭包")]),t._v(" "),s("blockquote",[s("p",[t._v("闭包：能够读取其他函数内部变量的函数。")])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("闭包三个特性(作用):")]),t._v(" "),s("p",[t._v("① 函数嵌套函数")]),t._v(" "),s("p",[t._v("② 函数内部可以引用函数外部的参数和变量，（"),s("code",[t._v("方便调用上下文的局部变量。利于代码封装）。")])]),t._v(" "),s("p",[t._v("③ 参数和变量不会被垃圾回收机制回收")])]),t._v(" "),s("li",[s("p",[t._v("闭包的好处")])])]),t._v(" "),s("p",[t._v("1.希望变量长期驻扎在内存当中（一般函数执行完毕，变量和参数会被销毁）")]),t._v(" "),s("p",[t._v("2.避免全局变量的污染")]),t._v(" "),s("h3",{attrs:{id:"_13-apply-call-bind-作用区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_13-apply-call-bind-作用区别"}},[t._v("#")]),t._v(" 13. apply call bind 作用区别")]),t._v(" "),s("p",[t._v("apply 、 call 、bind 三者都是用来改变函数的 this 对象的指向的；")]),t._v(" "),s("p",[t._v("apply 、 call 、bind 三者第一个参数都是 this 要指向的对象，也就是想指定的上下文；")]),t._v(" "),s("p",[t._v("apply 第二个参数必须是数组或者类数组，call 和 bind 的第二个及之后的参数作为函数实参按顺序传入")]),t._v(" "),s("p",[t._v("bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。")]),t._v(" "),s("h3",{attrs:{id:"_14-什么是类数组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14-什么是类数组"}},[t._v("#")]),t._v(" 14.什么是类数组")]),t._v(" "),s("p",[t._v("​ 具备与数组特征类似的对象")]),t._v(" "),s("h3",{attrs:{id:"_15-如何深度克隆一个对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_15-如何深度克隆一个对象"}},[t._v("#")]),t._v(" 15.如何深度克隆一个对象")]),t._v(" "),s("ul",[s("li",[t._v("1、判断是对象还是基本数据类型，是对象递归，不是对象直接 return")]),t._v(" "),s("li",[t._v("2、对象再区分数组对象还是 Object 对象。用不同的循环语句")])]),t._v(" "),s("h3",{attrs:{id:"_16-基本数据类型和引用类型的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_16-基本数据类型和引用类型的区别"}},[t._v("#")]),t._v(" 16.基本数据类型和引用类型的区别")]),t._v(" "),s("ul",[s("li",[t._v("1、基本类型的值是不可变得，引用类型的值是可变的")]),t._v(" "),s("li",[t._v("2、基本类型的比较是值的比较，引用类型的比较是引用地址的比较")]),t._v(" "),s("li",[t._v("3、基本类型的变量是存放在栈区的（栈区指内存里的栈内存），引用类型的值是同时保存在栈内存和堆内存中的对象")])]),t._v(" "),s("h3",{attrs:{id:"_17-数组去重的方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_17-数组去重的方法"}},[t._v("#")]),t._v(" 17.数组去重的方法")]),t._v(" "),s("ul",[s("li",[t._v("1、ES6 set 去重")]),t._v(" "),s("li",[t._v("2、双重 for 循环+splice 去重")]),t._v(" "),s("li",[t._v("3、声明新数组，用循环数组 arr.indexOf(arr[i]) === -1 去重")]),t._v(" "),s("li",[t._v("4、先 sort 排序，循环数组判断前后相等添加到新数组中")]),t._v(" "),s("li",[t._v("5、用 map key 唯一去重")]),t._v(" "),s("li",[t._v("详解："),s("a",{attrs:{href:"https://segmentfault.com/a/1190000016418021?utm_source=tag-newest",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://segmentfault.com/a/1190000016418021?utm_source=tag-newest"),s("OutboundLink")],1)])]),t._v(" "),s("h3",{attrs:{id:"_18-函数声明和函数表达式的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_18-函数声明和函数表达式的区别"}},[t._v("#")]),t._v(" 18.函数声明和函数表达式的区别")]),t._v(" "),s("ul",[s("li",[t._v("1、函数声明会被提升到当前作用域的顶部，函数表达式则不会。")]),t._v(" "),s("li",[t._v("2、函数声明一定会有函数名，而函数表达式一般不会有函数名。")]),t._v(" "),s("li",[t._v("3、函数声明不是一个完整的语句，所以不能出现在 if-else,for 循环，finally，try catch 语句以及 with 语句中,")])]),t._v(" "),s("h3",{attrs:{id:"_19-创建对象使用-、new-object-、object-create-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_19-创建对象使用-、new-object-、object-create-的区别"}},[t._v("#")]),t._v(" 19.创建对象使用{}、new object()、object.create()的区别")]),t._v(" "),s("h3",{attrs:{id:"_20-【js】点击-radio-后的文字实现选中效果"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_20-【js】点击-radio-后的文字实现选中效果"}},[t._v("#")]),t._v(" 20.【js】点击 radio 后的文字实现选中效果")]),t._v(" "),s("p",[t._v("只需要在 input 后面的文字套一个 label,然后加上 for 属性,值是对应的 radio 的 id 值"),s("br"),t._v(" "),s("code",[t._v("<input type='radio' id='male' name='sex' value='M'><label for='male'>男</label>")]),s("br"),t._v(" "),s("code",[t._v("<input type='radio' id='female' name='sex' value='F'><label for='female'>女</label>")])]),t._v(" "),s("h3",{attrs:{id:"_21-说说事件委托"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_21-说说事件委托"}},[t._v("#")]),t._v(" 21.说说事件委托")]),t._v(" "),s("ul",[s("li",[t._v("简介\n"),s("blockquote",[s("p",[t._v("又叫事件代理，JavaScript 高级程序设计上讲：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件\n事件代理：本来加在子元素身上的事件，加在了其父级身上\n事件委托是利用事件的冒泡原理来实现的，事件冒泡就是事件从最深的节点开始，然后逐步向上传播事件\n适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。")])])]),t._v(" "),s("li",[t._v("作用\n"),s("ul",[s("li",[t._v("第一个好处是效率高，比如，不用 for 循环为子元素添加事件了（假如说 100 个 li）")]),t._v(" "),s("li",[t._v("第二个好处是，js 新生成的子元素也不用新为其添加事件了，程序逻辑上比较方便")])])])]),t._v(" "),s("h3",{attrs:{id:"_21-1-父级那么多子元素，怎么区分事件本应该是哪个子元素的？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_21-1-父级那么多子元素，怎么区分事件本应该是哪个子元素的？"}},[t._v("#")]),t._v(" 21.1 父级那么多子元素，怎么区分事件本应该是哪个子元素的？")]),t._v(" "),s("blockquote",[s("p",[t._v("event 对象里记录的有“事件源”，它就是发生事件的子元素。\n它存在兼容性问题，在老的 IE 下，事件源是 window.event.srcElement，其他浏览器是 event.target")])]),t._v(" "),s("h3",{attrs:{id:"_22-js-怎么判断一个对象是-nan"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_22-js-怎么判断一个对象是-nan"}},[t._v("#")]),t._v(" 22 js 怎么判断一个对象是 NaN")]),t._v(" "),s("ul",[s("li",[s("ol",[s("li",[t._v("isNaN 结合 typeof 判断")])])])]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("isNaN")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("n")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" n "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'number'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("isNaN")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br")])]),s("ul",[s("li",[s("ol",{attrs:{start:"2"}},[s("li",[t._v("兼容性写法")])])])]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("Number"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("isNaN"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  Number"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("isNaN")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("n")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" n "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'number'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" window"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("isNaN")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("ul",[s("li",[s("ol",{attrs:{start:"3"}},[s("li",[t._v("利用 NaN 是唯一一个不等于任何自身的特点")])])])]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("isNaN")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("n")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!==")]),t._v(" n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br")])]),s("ul",[s("li",[s("ol",{attrs:{start:"4"}},[s("li",[t._v("利用 ES6 中提供的 Object.is()方法。\n"),s("code",[t._v("Object.is(c, NaN)")])])])])]),t._v(" "),s("h3",{attrs:{id:"_23-foreach-和-map-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_23-foreach-和-map-的区别"}},[t._v("#")]),t._v(" 23. forEach()和 map()的区别")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("共同点")]),t._v(" "),s("ul",[s("li",[t._v("都是循环遍历数组中的每一项")]),t._v(" "),s("li",[t._v("每一次执行匿名函数都支持三个参数，数组中的当前项 item，当前项的索引 index，原始数组 input")]),t._v(" "),s("li",[t._v("匿名函数中的 this 都是指 window")]),t._v(" "),s("li",[t._v("只能遍历数组")])])]),t._v(" "),s("li",[s("p",[t._v("forEach 没有返回值,")]),t._v(" "),s("ul",[s("li",[t._v("代码： "),s("code",[t._v("arr[].forEach(function(value,index,array){})")])]),t._v(" "),s("li",[t._v("参数：value 数组中的当前项，index 当前项的索引，array 原始数组；")]),t._v(" "),s("li",[t._v("数组中有几项，那么传递进去的匿名回调函数就需要执行几次")]),t._v(" "),s("li",[t._v("理论上这个方式是没有返回值的，只是遍历数组中的每一项，不对原来数组进行修改，但是可以自己通过数组的索引来修改原来的数组")])])]),t._v(" "),s("li",[s("p",[t._v("map()有返回值，可以 return 出来！！！")]),t._v(" "),s("ul",[s("li",[t._v("代码")])]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("map")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("array")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" xxx\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("ul",[s("li",[s("p",[t._v("参数：value 数组中的当前项，index 当前项的索引，array 原始数组")])]),t._v(" "),s("li",[s("p",[t._v("区别：map 的回调函数中支持 return 返回值，并不影响原来的数组，只是相当于把原数组克隆了一份，把克隆这一份的数组中的对应项改变了")])])])]),t._v(" "),s("li",[s("p",[t._v("$.each()方法规定为每个匹配元素规定运行的函数，可以返回 false 可用于及早停止循环。")])])]),t._v(" "),s("hr"),t._v(" "),s("ul",[s("li",[s("p",[t._v("内存泄漏")])]),t._v(" "),s("li",[s("p",[t._v("闭包")])]),t._v(" "),s("li",[s("p",[t._v("函数声明、函数表达式、匿名函数")]),t._v(" "),s("blockquote",[s("p",[t._v("函数声明：function functionName() {...}; 使用 function 关键字声明一个函数，再指定一个函数名，叫函数声明。函数声明后不会立即执行，会在我们需要的时候调用到。")])])])]),t._v(" "),s("p",[t._v("函数表达式：var test = function () {…};使用 function 关键字声明一个函数，但未给函数命名，最后将匿名函数赋予一个变量，叫函数表达式，这是最常见的函数表达式语法形式。")]),t._v(" "),s("p",[t._v("匿名函数：function () {}; 使用 function 关键字声明一个函数，但未给函数命名，所以叫匿名函数，匿名函数属于函数表达式，匿名函数有很多作用，赋予一个变量则创建函数，赋予一个事件则成为事件处理程序或创建闭包等等。")]),t._v(" "),s("ul",[s("li",[t._v("IIFE (立即调用的函数表达式)")]),t._v(" "),s("li",[t._v("事件循环，事件委托，事件冒泡，事件捕获")])]),t._v(" "),s("ul",[s("li",[t._v("斐波那契数列？怎么优化？")]),t._v(" "),s("li",[t._v("js 中的 new 操作符与 Object.create()的作用与区别")]),t._v(" "),s("li",[t._v("js 的 new 操作符做了哪些事情")]),t._v(" "),s("li",[t._v("prototype 和"),s("strong",[t._v("proto")]),t._v("的区别")]),t._v(" "),s("li",[t._v("原型继承和构造器继承区别")]),t._v(" "),s("li",[t._v("实现一个 repeat 函数，主要是闭包的应用")]),t._v(" "),s("li",[t._v("js 事件循环，异步，setTimout 和 promise 区别")]),t._v(" "),s("li",[t._v("改变函数内部 this 指针的指向函数（bind，apply，call 的区别）")]),t._v(" "),s("li",[t._v("JS 的回收机制")])]),t._v(" "),s("ul",[s("li",[t._v("0.1 + 0.2 等于 0.3 吗？为什么？解决方案？")])]),t._v(" "),s("h5",{attrs:{id:"手写函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#手写函数"}},[t._v("#")]),t._v(" 手写函数")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("手写实现"),s("code",[t._v("inherit")]),t._v("函数")])]),t._v(" "),s("li",[s("p",[t._v("手写实现"),s("code",[t._v("throttle")]),t._v("函数")])]),t._v(" "),s("li",[s("p",[t._v("自己实现一个 bind 函数")])]),t._v(" "),s("li",[s("p",[t._v("js 手写 ajax")])]),t._v(" "),s("li",[s("p",[t._v("js 手写 promise")])]),t._v(" "),s("li",[s("p",[t._v("js 手写数组方法 "),s("a",{attrs:{href:"https://blog.csdn.net/jacoox/article/details/82693994",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://blog.csdn.net/jacoox/article/details/82693994"),s("OutboundLink")],1)]),t._v(" "),s("blockquote",[s("p",[t._v("改变原数组的方法\narr.push();\narr.pop();\narr.unshift();\narr.shift();\narr.reverse();\narr.splice();\narr.sort();\narr.copyWithin();\n不改变原数组的方法\narr.concat();\narr.toString();\narr.slice();\narr.join();\narr.split();\narr.forEach();\narr.map();\narr.filter();\narr.some();\narr.every();\narr.concat();")])])]),t._v(" "),s("li",[s("p",[t._v("js 排序算法 ，冒泡排序，快速排序")])]),t._v(" "),s("li",[s("p",[t._v("js 数组去重")])]),t._v(" "),s("li",[s("p",[t._v("js 实现千分位")])]),t._v(" "),s("li",[s("p",[t._v("js 手写 vue 双向绑定")])])]),t._v(" "),s("h5",{attrs:{id:"笔试"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#笔试"}},[t._v("#")]),t._v(" 笔试")]),t._v(" "),s("ul",[s("li",[t._v("实现一个函数，判断输入是不是回文字符串。")])]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])])])}),[],!1,null,null,null);a.default=e.exports}}]);