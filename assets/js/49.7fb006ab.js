(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{397:function(t,l,a){"use strict";a.r(l);var _=a(43),s=Object(_.a)({},(function(){var t=this,l=t.$createElement,a=t._self._c||l;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"算法基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#算法基础"}},[t._v("#")]),t._v(" 算法基础")]),t._v(" "),a("h3",{attrs:{id:"_1-时间复杂度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-时间复杂度"}},[t._v("#")]),t._v(" 1.时间复杂度")]),t._v(" "),a("ul",[a("li",[t._v("时间复杂度")])]),t._v(" "),a("blockquote"),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("1. 最坏情况时间复杂度：代码在最理想情况下执行的时间复杂度。  \n2. 最好情况时间复杂度：代码在最坏情况下执行的时间复杂度。  \n3. 平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。  \n4. 均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。  \n")])])]),a("ul",[a("li",[a("p",[t._v("求解算法的时间复杂度的具体步骤")]),t._v(" "),a("ul",[a("li",[t._v("⑴ 找出算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。")]),t._v(" "),a("li",[t._v("⑵ 计算基本语句的执行次数的数量级；")]),t._v(" "),a("li",[t._v("⑶ 用大Ο记号表示算法的时间性能。")])])]),t._v(" "),a("li",[a("p",[t._v("分析一段代码的时间复杂度的三个方法")]),t._v(" "),a("ul",[a("li",[t._v("只关注循环执行次数最多的的一段代码")]),t._v(" "),a("li",[t._v("加法法则：总复杂度等于量级最大的那段代码的复杂度")]),t._v(" "),a("li",[t._v("乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积")])])])])])}),[],!1,null,null,null);l.default=s.exports}}]);