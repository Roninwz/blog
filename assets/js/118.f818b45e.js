(window.webpackJsonp=window.webpackJsonp||[]).push([[118],{466:function(s,t,a){"use strict";a.r(t);var n=a(43),e=Object(n.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"js-事件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js-事件"}},[s._v("#")]),s._v(" js 事件")]),s._v(" "),a("h3",{attrs:{id:"事件机制组成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件机制组成"}},[s._v("#")]),s._v(" 事件机制组成")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("1.事件源：即事件的发送者")])]),s._v(" "),a("li",[a("p",[s._v("2.事件：事件源发出的一种信息或状态")])]),s._v(" "),a("li",[a("p",[s._v("3.事件侦听者：对事件作出反应的对象")])])]),s._v(" "),a("h3",{attrs:{id:"事件流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件流"}},[s._v("#")]),s._v(" 事件流")]),s._v(" "),a("blockquote",[a("p",[s._v("事件流描述的是从页面中接受事件的顺序\nIE 的事件流是事件冒泡流(event bubbling)，而 Netscape(网景开发团队) 的事件流是事件捕获流(event capturing)。\n事件流：分为捕获阶段、处于目标阶段、冒泡阶段三个阶段")])]),s._v(" "),a("h3",{attrs:{id:"dom-2-级事件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dom-2-级事件"}},[s._v("#")]),s._v(" DOM 2 级事件")]),s._v(" "),a("blockquote",[a("p",[s._v("DOM 2 级事件定义了两方法：用于处理添加事件和删除事件的操作： 添加事件 addEventListener() 删除事件 removeEventListener()")])]),s._v(" "),a("blockquote",[a("p",[s._v("所有 DOM 节点中都包含这两个方法，并且他们都包含 3 个参数： （1） 要处理的事件方式（例如：click，mouseover,dbclick.....） （2）事件处理的函数，可以为匿名函数，也可以为命名函数（但如果需要删除事件，必须是命名函数） （3）一个布尔值，代表是处于事件冒泡阶段处理还是事件捕获阶段（true：表示在捕获阶段调用事件处理程序；false:表示在冒泡阶段调用事件处理程序）")])]),s._v(" "),a("h3",{attrs:{id:"js-异步执行的运行机制。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js-异步执行的运行机制。"}},[s._v("#")]),s._v(" js 异步执行的运行机制。")]),s._v(" "),a("blockquote",[a("p",[s._v('所有任务都在主线程上执行，形成一个执行栈。\n主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。\n一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"。那些对应的异步任务，结束等待状态，进入执行栈并开始执行。\n主线程不断重复上面的第三步。')])]),s._v(" "),a("h3",{attrs:{id:"事件执行"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件执行"}},[s._v("#")]),s._v(" 事件执行")]),s._v(" "),a("blockquote",[a("p",[s._v("1.事件的执行顺序，是先执行宏任务，然后执行微任务\n2、队列的特征是先进先出\n3、js 是单线程的，任务都是排队执行，不会同步执行对个任务\n4、js 分为同步（赋值，循环，分支语句）和异步（ajax，dom 事件，定时器）")])]),s._v(" "),a("h3",{attrs:{id:"js-执行机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js-执行机制"}},[s._v("#")]),s._v(" js 执行机制")]),s._v(" "),a("ul",[a("li",[s._v("1.取且仅取一个宏任务来执行（第一个宏任务就是 script 任务）。执行过程中判断是同步还是异步任务，如果是同步任务就进入主线程执行栈中，如果是异步任务就进入异步处理模块，这些异步处理模块的任务当满足触发条件后，进入任务队列，进入任务队列后，按照宏任务和微任务进行划分，划分完毕后，执行下一步。")]),s._v(" "),a("li",[s._v("2.如果微任务队列不为空，则依次取出微任务来执行，直到微任务队列为空（即当前 loop 所有微任务执行完），执行下一步。")]),s._v(" "),a("li",[s._v("3.进入下一轮 loop 或更新 UI 渲染。")])]),s._v(" "),a("h3",{attrs:{id:"js-任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js-任务"}},[s._v("#")]),s._v(" js 任务")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("宏任务(macro)task 主要包含："),a("br"),s._v("\nscript( 整体代码)、"),a("br"),s._v("\nsetTimeout、"),a("br"),s._v("\nsetInterval、"),a("br"),s._v("\nI/O、UI 交互事件、"),a("br"),s._v("\nsetImmediate(Node.js 环境)")])]),s._v(" "),a("li",[a("p",[s._v("微任务 microtask 主要包含："),a("br"),s._v("\nPromise 的 then 或 catch,"),a("br"),s._v("\nObject.observer（已废弃）,"),a("br"),s._v("\nMutationObserver."),a("br"),s._v("\nprocess.nextTick(Node.js 环境)")])])]),s._v(" "),a("h3",{attrs:{id:"消息队列和事件循环"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#消息队列和事件循环"}},[s._v("#")]),s._v(" 消息队列和事件循环")]),s._v(" "),a("p",[s._v("异步过程中，工作线程在异步操作完成后需要通知主线程，那么通知机制是怎么样的呢？就是利用消息队列和事件循环。")]),s._v(" "),a("p",[s._v("工作线程将消息放到消息队列，主线程通过事件循环过程去取消息。\n消息队列： 消息队列是一个先进先出的队列，里面放着各种各样的消息；\n事件循环： 事件循环是指主线程重复从消息队列中取消息，执行的过程。\n实际上，主线程只会做一件事情，就是从消息队列里面取消息、执行消息，再取消息、再执行。当消息队列为空时，就会等待直到消息队列变成非空。而且主线程只有在将当前的消息执行完成后，才会去取下一个消息。这种机制就叫做事件循环机制，取一个消息并执行的过程叫做一次循环。")]),s._v(" "),a("p",[s._v("事件循环用代码表示大概是这样的：")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("while")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[s._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" message "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" queue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("get")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("execute")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("message"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("那么，消息队列中放的消息具体是什么东西？消息的具体结构当然跟具体的实现有关，但是为了简单起见，我们可以认为：")]),s._v(" "),a("p",[s._v("消息就是注册异步任务时添加的回调函数。\n再次以异步 AJAX 为例，假设存在如下的代码：")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[s._v("\\$"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("ajax")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'http://segmentfault.com'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("function")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[s._v("resp")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'我是响应：'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" resp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("p",[s._v("主线程在发起 AJAX 请求后，会继续执行其他代码。AJAX 线程负责请求 segmentfault.com，拿到响应后，它会把响应封装成一个 JavaScript 对象，然后构造一条消息：")]),s._v(" "),a("p",[s._v("// 消息队列中的消息就长这个样子")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[s._v("message")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("function")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("callbackFn")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("response"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("p",[s._v("// 其中的 callbackFn 就是前面代码中得到成功响应时的回调函数。\n主线程在执行完当前循环中的所有代码后，就会到消息队列取出这条消息(也就是 message 函数)，并执行它。到此为止，就完成了工作线程对主线程的通知，回调函数也就得到了执行。如果一开始主线程就没有提供回调函数，AJAX 线程在收到 HTTP 响应后，也就没必要通知主线程，从而也没必要往消息队列放消息。")]),s._v(" "),a("h3",{attrs:{id:"_1、什么是单线程？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、什么是单线程？"}},[s._v("#")]),s._v(" 1、什么是单线程？")]),s._v(" "),a("p",[s._v("单线程在程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行。简单来说，即同一时间只能做一件事件。")]),s._v(" "),a("h3",{attrs:{id:"_2、js-为什么是单线程？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、js-为什么是单线程？"}},[s._v("#")]),s._v(" 2、Js 为什么是单线程？")]),s._v(" "),a("p",[s._v("Js 是一种运行在网页的简单的脚本语言，由于设计的初衷是作为浏览器脚本语言，用于与用户互动，以及操作 DOM。这决定它是单线程的。")]),s._v(" "),a("h3",{attrs:{id:"_3、单线程带来的问题？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、单线程带来的问题？"}},[s._v("#")]),s._v(" 3、单线程带来的问题？")]),s._v(" "),a("p",[s._v("单线程就意味着，所有任务都需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就需要一直等着。这就会导致 IO 操作（耗时但 cpu 闲置）时造成性能浪费的问题。")]),s._v(" "),a("h3",{attrs:{id:"_4、如何解决单线程的性能问题？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、如何解决单线程的性能问题？"}},[s._v("#")]),s._v(" 4、如何解决单线程的性能问题？")]),s._v(" "),a("p",[s._v("采用异步可以解决。主线程完全可以不管 IO 操作，暂时挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。于是，所有任务可以分成两种，一种是同步任务，另一种是异步任务。")])])}),[],!1,null,null,null);t.default=e.exports}}]);